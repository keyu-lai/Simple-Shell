diff --git a/shell/Link.c b/shell/Link.c
new file mode 100644
index 0000000..bec9aa3
--- /dev/null
+++ b/shell/Link.c
@@ -0,0 +1,124 @@
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include "Link.h"
+
+void malloc_failure(void)
+{
+	printf("error: %s\n", strerror(errno));
+	exit(EXIT_FAILURE);	
+}
+
+void Init_link(struct Link *link)
+{
+	link->head = malloc(sizeof(struct Node));
+	if (link->head == NULL)
+		malloc_failure();
+	link->tail = malloc(sizeof(struct Node));
+	if (link->tail == NULL)
+		malloc_failure();
+	link->head->str = malloc(sizeof(char));
+	if (link->head->str == NULL)
+		malloc_failure();
+	link->head->prev = NULL;
+	link->head->next = link->tail;
+	link->tail->str = malloc(sizeof(char));
+	if (link->tail->str == NULL)
+		malloc_failure();
+	link->tail->prev = link->head;
+	link->tail->next = NULL;
+	link->num = 0;
+}
+
+int check_duplicate(struct Link *link, const char *str)
+{
+	struct Node *p = link->head;
+
+	while ((p = p->next) != link->tail) {
+		if (!strcmp(p->str, str))
+			return 1;
+	}
+	return 0;
+}
+
+void insert(struct Link *link, const char *str)
+{
+	struct Node *p = link->tail->prev;
+
+	link->tail->prev = malloc(sizeof(struct Node));
+	if (link->tail->prev == NULL)
+		malloc_failure();
+	link->tail->prev->str = malloc((strlen(str) + 1) * sizeof(char));
+	if (link->tail->prev->str == NULL)
+		malloc_failure();
+	strcpy(link->tail->prev->str, str);
+	p->next = link->tail->prev;
+	p->next->next = link->tail;
+	p->next->prev = p;
+	++(link->num);
+}
+
+void delete_str(struct Link *link, const char *str)
+{
+	struct Node *p = link->head;
+	struct Node *tmp;
+
+	while ((p = p->next) != link->tail) {
+		if (!strcmp(p->str, str)) {
+			p->next->prev = p->prev;
+			p->prev->next = p->next;
+			tmp = p;
+			p = p->prev;
+			free(tmp->str);
+			free(tmp);
+			--(link->num);
+		}
+	}
+}
+
+void delete_last(struct Link *link)
+{
+	struct Node *p = link->tail->prev;
+
+	if (p == link->head)
+		return;
+	link->tail->prev = p->prev;
+	p->prev->next = p->next;
+	free(p->str);
+	free(p);
+	--(link->num);
+}
+
+void delete_first(struct Link *link)
+{
+	struct Node *tmp = link->head->next;
+
+	if (tmp == link->tail)
+		return;
+	link->head->next = tmp->next;
+	tmp->next->prev = link->head;
+	free(tmp->str);
+	free(tmp);
+	--(link->num);
+}
+
+void clear(struct Link *link)
+{
+	struct Node *p = link->head;
+	struct Node *tmp;
+
+	while (p != NULL) {
+		tmp = p->next;
+		free(p->str);
+		free(p);
+		p = tmp;
+	}
+	link->num = 0;
+}
+
+int size(struct Link *link)
+{
+	return link->num;
+}
+
diff --git a/shell/Link.h b/shell/Link.h
new file mode 100644
index 0000000..1a05030
--- /dev/null
+++ b/shell/Link.h
@@ -0,0 +1,26 @@
+#ifndef LINK_H_
+#define LINK_H_
+
+struct Node {
+	char *str;
+	struct Node *prev;
+	struct Node *next;
+};
+
+struct Link {
+	struct Node *head;
+	struct Node *tail;
+	int num;
+};
+
+void malloc_failure(void);
+void Init_link(struct Link *link);
+void insert(struct Link *link, const char *str);
+void delete_str(struct Link *link, const char *str);
+void delete_first(struct Link *link);
+void clear(struct Link *link);
+int size(struct Link *link);
+void delete_last(struct Link *link);
+int check_duplicate(struct Link *link, const char *str);
+
+#endif
diff --git a/shell/shell.c b/shell/shell.c
index 07b0fbf..d5c22bd 100644
--- a/shell/shell.c
+++ b/shell/shell.c
@@ -1,3 +1,290 @@
-int main(int argc, char **argv) {
-	return 0;
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <linux/limits.h>
+#include <errno.h>
+#include <sys/wait.h>
+#include <sys/types.h>
+#include "Link.h"
+
+char *read_line(void);
+char **parse_command(char *line, int *num, char *delim);
+void shell_pwd(int num);
+void shell_cd(char **args, int num);
+void print_paths(void);
+void shell_path(char **args, int num);
+void search(char **args, int num);
+int shell_execute(char **args, int num);
+void print_history(void);
+void shell_history(char **args, int num);
+int shell_cmd(char *line);
+void execute_his(const char* str);
+
+struct Link paths;
+struct Link history;
+
+int main(int argc, char **argv)
+{
+	char *line;
+
+	Init_link(&paths);
+	Init_link(&history);
+	
+	while (1) {
+		printf("$");
+		line = read_line();
+		if (shell_cmd(line))
+			break;
+	}
+
+	clear(&paths);
+	clear(&history);
+	return EXIT_SUCCESS;
 }
+
+#define EXIT_LOOP 1
+#define CONTINUE_LOOP 0
+int shell_cmd(char *line)
+{
+	int num;
+	char **args;
+	int res = CONTINUE_LOOP;
+
+	insert(&history, line);
+	args = parse_command(line, &num, " ");
+	if (num == 0)
+		delete_last(&history);
+	else if (!strcmp(args[0], "exit"))
+		res = EXIT_LOOP;
+	else if (!strcmp(args[0], "cd"))
+		shell_cd(args, num);
+	else if (!strcmp(args[0], "pwd"))
+		shell_pwd(num);
+	else if (!strcmp(args[0], "path"))
+		shell_path(args, num);
+	else if (!strcmp(args[0], "history"))
+		shell_history(args, num);
+	else
+		res = shell_execute(args, num);
+	free(line);
+	free(args);
+	return res;
+}
+
+int shell_execute(char **args, int num)
+{
+	int pid;
+
+	pid = fork();
+	if (pid < 0) {
+		printf("error: %s\n", strerror(errno));
+		exit(EXIT_FAILURE);	
+	} 
+	if (pid == 0) {
+		search(args, num);
+		return EXIT_LOOP;
+	}
+	else {
+		int return_code;
+
+		while (pid != wait(&return_code));
+		return CONTINUE_LOOP;
+	}
+}
+
+void search(char **args, int num)
+{
+	char *exc_dir;
+	struct Node *p = paths.head;
+
+	if (index(args[0], '/') != NULL) {
+		execv(args[0], args);
+		printf("error: %s\n", strerror(errno));
+		return;
+	}
+	if (size(&paths) == 0) {
+		printf("error: %s\n", "No such file or directory");
+		return;
+	}
+	while ((p = p->next) != paths.tail) {
+		int dir_len = strlen(p->str) + strlen(args[0]) + 2;
+		exc_dir = malloc(dir_len * sizeof(char));
+		if(exc_dir == NULL)
+			malloc_failure();
+		strcpy(exc_dir, p->str);
+		if (exc_dir[strlen(exc_dir)-1] != '/')
+			strcat(exc_dir, "/");
+		strcat(exc_dir, args[0]);
+		execv(exc_dir, args);
+		free(exc_dir);
+	}
+	printf("error: %s\n", strerror(errno));
+}
+
+#define HISTORY_MAX 100
+void print_history(void)
+{
+	int i = 0;
+	struct Node *p = history.head;
+
+	while (size(&history) > HISTORY_MAX)
+		delete_first(&history);
+	while ((p = p->next) != history.tail)
+		printf("%d %s\n", i++, p->str);
+}
+
+void execute_his(const char *str)
+{
+	char *line;
+
+	line = malloc((strlen(str) + 1) * sizeof(char));
+	if (line == NULL)
+		malloc_failure();
+	strcpy(line, str);
+	shell_cmd(line);
+}
+
+void shell_history(char **args, int num)
+{
+	int i;
+	int his_num;
+	struct Node *p;
+
+	delete_last(&history);
+	if (num == 1) {
+		print_history();
+		return;
+	}
+	if (num > 2) {
+		printf("error: %s\n", "Invalid history command");
+		return;	
+	}
+	if (!strcmp(args[1], "-c")) {
+		clear(&history);
+		Init_link(&history);
+		return;
+	}
+	
+	for (i = 0; i < strlen(args[1]); ++i) {
+		if (args[1][i] > '9' || args[1][i] < '0') {
+			printf("error: %s\n", "Invalid history command");
+			return;
+		}
+	}
+	his_num = atoi(args[1]);
+	if (his_num >= size(&history) || his_num >= HISTORY_MAX) {
+		printf("error: %s\n", "Invalid history command");
+		return;
+	}
+
+	p = history.head;
+	while ((p = p->next) != history.tail) {
+		if (--his_num < 0) {
+			execute_his(p->str);
+			return;
+		}			
+	}		
+}
+
+void print_paths(void)
+{
+	struct Node *p = paths.head->next;
+
+	if (p == paths.tail) {
+		printf("\n");
+		return;
+	}
+	printf("%s", p->str);
+	while ((p = p->next) != paths.tail) {
+		printf(":%s", p->str);
+	}
+	printf("\n");
+}
+
+void shell_path(char **args, int num)
+{
+	if (num == 1) {
+		print_paths();
+		return;
+	}
+	if (num == 2 || num > 3) {
+		printf("error: %s\n", "Invalid path command");
+		return;
+	}
+
+	if (!strcmp(args[1], "+")) {
+		if (!check_duplicate(&paths, args[2]))	
+			insert(&paths, args[2]);
+	} else if (!strcmp(args[1], "-"))
+		delete_str(&paths, args[2]);
+	else
+		printf("error: %s\n", "Invalid path command");
+}
+
+void shell_pwd(int num)
+{
+	char cwd[PATH_MAX];
+
+	if (num > 1) {
+		printf("error: %s\n", "Invalid pwd command");
+		return;
+	}
+
+	if (getcwd(cwd, PATH_MAX) == NULL) {
+		printf("error: %s\n", strerror(errno));
+		return;
+	}
+	printf("%s\n", cwd);
+}
+
+void shell_cd(char **args, int num)
+{
+	if (num != 2) {
+		printf("error: %s\n", "Invalid cd command");
+		return;
+	}
+	if (chdir(args[1]) != 0) {
+		printf("error: %s\n", strerror(errno));
+		return;
+	}
+}
+
+#define MAX_ARG 128
+char **parse_command(char *line, int *num, char *delim)
+{
+	char *arg;
+	char **args = malloc(MAX_ARG * sizeof(char *));
+
+	if (args == NULL)
+		malloc_failure();
+	*num = 0;
+	arg = strtok(line, delim);
+	for (; arg != NULL; arg = strtok(NULL, delim)) {
+		args[(*num)++] = arg;
+		if ((*num) >= MAX_ARG-1) {
+			printf("error: %s\n", "Excess maximum arguments");
+			*num = 0;
+			return args;
+		}
+	}
+	return args;
+}
+
+char *read_line(void)
+{
+	char *line = NULL;
+	size_t len = 0;
+
+	if (getline(&line, &len, stdin) == -1) {
+		printf("error: %s\n", "Cannot read a line");
+		free(line);
+		exit(EXIT_FAILURE);
+	}
+	len = strlen(line);
+	if (line[len-1] == EOF || line[len-1] == '\n')
+		line[len-1] = '\0';
+	return line;
+}
+
+
